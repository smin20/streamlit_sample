import warnings
warnings.filterwarnings("ignore", message="findfont: Font family 'Malgun Gothic' not found.")

import streamlit as st
import datetime 
import matplotlib.pyplot as plt
import mplfinance as mpf
import numpy as np
import pandas as pd
from pykrx import stock
import sqlite3
import json
import logging

# Î°úÍ∑∏ ÏÑ§Ï†ï: Í∏∞Î≥∏ ÌòïÏãùÏùÑ ÏßÄÏ†ïÌïòÍ≥†, INFO Î†àÎ≤® Ïù¥ÏÉÅÏùò Î°úÍ∑∏Î•º Ï∂úÎ†•ÌïòÎèÑÎ°ù Ìï©ÎãàÎã§.
logging.basicConfig(
    format="%(asctime)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)
# ÌéòÏù¥ÏßÄ ÏÑ§Ï†ï (ÎÑìÏùÄ Î†àÏù¥ÏïÑÏõÉ)
st.set_page_config(layout="wide")

# Ïï± Ï†úÎ™© (ÏïÑÏù¥ÏΩò Ï∂îÍ∞Ä)
st.info('ü™Ñ Îß§ÏßÅÏä§ÌîåÎ¶ø Í≤∞Í≥º Î∞±ÌÖåÏä§ÌåÖ ÌéòÏù¥ÏßÄ ÏûÖÎãàÎã§. Ï¢ÖÎ™© ÏÑ†ÌÉù ÌõÑ üöÄ Î∞±ÌÖåÏä§Ìä∏ Ïã§Ìñâ Î≤ÑÌäº ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî.')

# ---------------------------------------
# ÏÇ¨Ïù¥ÎìúÎ∞î: Ï¢ÖÎ™© Í≤ÄÏÉâ Î∞è ÏÑ†ÌÉù (ÏïÑÏù¥ÏΩò Ï∂îÍ∞Ä)
# ---------------------------------------
st.sidebar.header("üîç Ï¢ÖÎ™© Í≤ÄÏÉâ")
search_query = st.sidebar.text_input("üîé Ï¢ÖÎ™© Ïù¥Î¶Ñ ÏûÖÎ†• (Ïòà: ÏÇºÏÑ±)", key="search_query")

@st.cache_data
def load_ticker_info():
    # KOSPI, KOSDAQ Ï†ÑÏ≤¥ Ìã∞Ïª§ÏôÄ Ïù¥Î¶Ñ Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏ÏòµÎãàÎã§.
    tickers_kospi = stock.get_market_ticker_list(market="KOSPI")
    tickers_kosdaq = stock.get_market_ticker_list(market="KOSDAQ")
    ticker_dict = {}
    for t in tickers_kospi:
        try:
            ticker_dict[t] = stock.get_market_ticker_name(t)
        except Exception:
            ticker_dict[t] = "Unknown"
    for t in tickers_kosdaq:
        try:
            ticker_dict[t] = stock.get_market_ticker_name(t)
        except Exception:
            ticker_dict[t] = "Unknown"
    return ticker_dict

@st.cache_data(show_spinner=False)
def get_market_cap(ticker, date_str):
    """
    ÏßÄÏ†ïÌïú ÎÇ†Ïßú(date_str: 'YYYYMMDD') Í∏∞Ï§ÄÏúºÎ°ú Ìï¥Îãπ Ï¢ÖÎ™©Ïùò ÏãúÍ∞ÄÏ¥ùÏï°ÏùÑ Î∞òÌôòÌï©ÎãàÎã§.
    Ï°∞ÌöåÏóê Ïã§Ìå®ÌïòÎ©¥ 0ÏùÑ Î∞òÌôòÌï©ÎãàÎã§.
    """
    try:
        df_cap = stock.get_market_cap_by_date(date_str, date_str, ticker)
        if df_cap.empty:
            return 0
        # df_capÏùò 'ÏãúÍ∞ÄÏ¥ùÏï°' Ïª¨Îüº Í∞í Î∞òÌôò (ÌïÑÏöîÏóê Îî∞Îùº Îç∞Ïù¥ÌÑ∞ Ï†ÑÏ≤òÎ¶¨ ÌïÑÏöî)
        return df_cap['ÏãúÍ∞ÄÏ¥ùÏï°'].iloc[0]
    except Exception:
        return 0

if search_query:
    ticker_info = load_ticker_info()
    # Í≤ÄÏÉâÏñ¥Í∞Ä Ï¢ÖÎ™©Î™ÖÏóê Ìè¨Ìï®Îêú Ìã∞Ïª§Îì§ ÌïÑÌÑ∞ÎßÅ (ÎåÄÏÜåÎ¨∏Ïûê Íµ¨Î∂Ñ ÏóÜÏù¥)
    filtered_tickers = {code: name for code, name in ticker_info.items() if search_query in name}
    if filtered_tickers:
        # Ïò§Îäò ÎÇ†Ïßú Í∏∞Ï§ÄÏúºÎ°ú ÏãúÍ∞ÄÏ¥ùÏï° Ï°∞Ìöå (Î¨∏ÏûêÏó¥ 'YYYYMMDD' ÌòïÏãù)
        today_str = datetime.datetime.today().strftime("%Y%m%d")
        # (Ìã∞Ïª§, Ï¢ÖÎ™©Î™Ö) ÌäúÌîå Î¶¨Ïä§Ìä∏Î•º ÏãúÍ∞ÄÏ¥ùÏï° Í∏∞Ï§Ä ÎÇ¥Î¶ºÏ∞®ÏàúÏúºÎ°ú Ï†ïÎ†¨
        sorted_filtered_tickers = sorted(
            filtered_tickers.items(),
            key=lambda x: get_market_cap(x[0], today_str),
            reverse=True
        )
        # selectboxÏóê Ï†ïÎ†¨Îêú Í≤∞Í≥º ÌëúÏãú ("Ìã∞Ïª§ - Ï¢ÖÎ™©Î™Ö" ÌòïÏãù)
        selected = st.sidebar.selectbox(
            "üìã Í≤ÄÏÉâ Í≤∞Í≥º",
            sorted_filtered_tickers,
            format_func=lambda x: f"{x[0]} - {x[1]}"
        )
        target_ticker = selected[0]
        st.sidebar.write(f"‚úÖ ÏÑ†ÌÉùÎêú Ï¢ÖÎ™©: **{selected[0]} ({selected[1]})**")
    else:
        st.sidebar.write("‚ùå Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§.")
        target_ticker = None
else:
    st.sidebar.write("‚ÑπÔ∏è Ï¢ÖÎ™© Í≤ÄÏÉâÏñ¥Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.")
    target_ticker = None

# ---------------------------------------
# ÏÇ¨Ïù¥ÎìúÎ∞î: Í∏∞Ï¥à ÏÑ§Ï†ï (ÏïÑÏù¥ÏΩò Ï∂îÍ∞Ä)
# ---------------------------------------
st.sidebar.header('‚öôÔ∏è Í∏∞Ï¥à ÏÑ§Ï†ï')
initial_investment = st.sidebar.number_input('üí∞ Ï¥ù Ìà¨ÏûêÍ∏àÏï°', value=5000000, step=100000)
unit_investment = st.sidebar.number_input('üìå 1Ï∞®ÏàòÎãπ Í∏àÏï°', value=500000, step=50000)
max_buy_times = st.sidebar.number_input('üîÅ ÏµúÎåÄ Îß§Ïàò ÌöüÏàò', value=10, min_value=1, step=1)

# -------------------------------
# ÏÇ¨Ïù¥ÎìúÎ∞î: ÎÇ†Ïßú Î≤îÏúÑ ÏÑ§Ï†ï (ÏïÑÏù¥ÏΩò Ï∂îÍ∞Ä)
# -------------------------------
st.sidebar.header('üìÖ ÎÇ†Ïßú Î≤îÏúÑ ÏÑ§Ï†ï (Í∏∞Î≥∏ 6Í∞úÏõî)')
start_date_input = st.sidebar.date_input('ÏãúÏûë ÎÇ†Ïßú', datetime.datetime.today() - datetime.timedelta(days=180))
end_date_input = st.sidebar.date_input('Ï¢ÖÎ£å ÎÇ†Ïßú', datetime.datetime.today())
start_date = start_date_input.strftime('%Y%m%d')
end_date = end_date_input.strftime('%Y%m%d')

if st.sidebar.button('üöÄ Î∞±ÌÖåÏä§Ìä∏ Ïã§Ìñâ'):
    log_line = f"{datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')} - Î∞±ÌÖåÏä§Ìä∏ Ïã§ÌñâÎê®"
    if target_ticker:
        log_line += f" (Ï¢ÖÎ™©: {target_ticker} - {stock.get_market_ticker_name(target_ticker)})"
    else:
        log_line += " (Ï¢ÖÎ™© ÎØ∏ÏÑ†ÌÉù)"
    
    # Î°úÍ∑∏ Ï∂úÎ†•
    logging.info(log_line)
    
    if not target_ticker:
        st.error("‚ùó Ï¢ÖÎ™©ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.")
        st.stop()
    
    # Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
    try:
        st.write(f'üìà Ï¢ÖÎ™© ÏΩîÎìú {target_ticker} ({stock.get_market_ticker_name(target_ticker)}) Ïùò Îç∞Ïù¥ÌÑ∞Î•º {start_date_input}Î∂ÄÌÑ∞ {end_date_input}ÍπåÏßÄ Í∞ÄÏ†∏ÏòµÎãàÎã§.')
        df = stock.get_market_ohlcv_by_date(start_date, end_date, target_ticker)
        df.index = pd.to_datetime(df.index)
        df.sort_index(inplace=True)
    except Exception as e:
        st.error(f'‚ùó Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏ†∏Ïò§Îäî Ï§ë Ïò§Î•ò Î∞úÏÉù: {e}')
        st.stop()
    
    # Í≤∞Í≥ºÎ•º Ï†ÄÏû•Ìï† Î¶¨Ïä§Ìä∏ Ï¥àÍ∏∞Ìôî
    results = []
    
    # Îß§Ïàò Í∞≠ %ÏôÄ Îß§ÎèÑ %Ïùò Î≤îÏúÑ ÏÑ§Ï†ï (Í≥†Ï†ï Í∞í)
    buy_next_percent_start = 5.00
    buy_next_percent_end = 10.00
    buy_next_percent_step = 1.0
    sell_percent_start = 1.00
    sell_percent_end = 5.00
    sell_percent_step = 0.5
    
    # ÏßÑÌñâÎ∞î
    my_bar = st.progress(0)
    total_iterations = int(len(np.arange(buy_next_percent_start, buy_next_percent_end + buy_next_percent_step, buy_next_percent_step)) * 
                           len(np.arange(sell_percent_start, sell_percent_end + sell_percent_step, sell_percent_step)))
    iteration = 0
    
    # -------------------------------
    # Î∞±ÌÖåÏä§ÌåÖ Ïã§Ìñâ (Îß§Ïàò Í∞≠ %ÏôÄ Îß§ÎèÑ %Ïùò Î™®Îì† Ï°∞Ìï©Ïóê ÎåÄÌï¥)
    # -------------------------------
    for buy_next_percent in np.arange(buy_next_percent_start, buy_next_percent_end + buy_next_percent_step, buy_next_percent_step):
        for sell_percent in np.arange(sell_percent_start, sell_percent_end + sell_percent_step, sell_percent_step):
            iteration += 1
            # ÌçºÏÑºÌä∏ Í∞íÏùÑ ÏÜåÏàòÎ°ú Î≥ÄÌôò
            buy_next_percent_decimal = buy_next_percent / 100
            sell_percent_decimal = sell_percent / 100
            
            holdings = 0  # Î≥¥Ïú† Ï£ºÏãù Ïàò (Ï†ïÏàò)
            cash = initial_investment
            
            # ÏàòÏàòÎ£å Î∞è ÏÑ∏Í∏à ÏÑ§Ï†ï (ÌÇ§ÏõÄÏ¶ùÍ∂å Í∏∞Ï§Ä)
            commission_rate = 0.00015       # Îß§Ïàò/Îß§ÎèÑ ÏàòÏàòÎ£å 0.015%
            transaction_tax_rate = 0.0018   # Îß§ÎèÑ Ïãú Í±∞ÎûòÏÑ∏ 0.18%
            
            # Î≥ÄÏàò Ï¥àÍ∏∞Ìôî
            initial_buy_price = None          # 1Ï∞® Îß§Ïàò Í∞ÄÍ≤© Ï†ÄÏû•
            waiting_for_initial_price = False # 1Ï∞® Îß§Ïàò Í∞ÄÍ≤©ÍπåÏßÄ ÌïòÎùΩ ÎåÄÍ∏∞ ÏÉÅÌÉú
            buy_count = 0                     # ÌòÑÏû¨ Î≥¥Ïú† Ï§ëÏù∏ Îß§Ïàò Ï∞®Ïàò
            buy_levels = []                   # Î≥¥Ïú† Ï§ëÏù∏ Îß§Ïàò Î†àÎ≤®Î≥Ñ Í∞ÄÍ≤© Î∞è ÏàòÎüâ
            
            # Îß§Ïàò Í∞ÄÎä• Ï£ºÏãù Ïàò Í≥ÑÏÇ∞ Ìï®Ïàò
            def calculate_number_of_shares_to_buy(cash_available, unit_investment, price, commission_rate):
                max_investment = min(cash_available, unit_investment)
                number_of_shares = int(max_investment // (price * (1 + commission_rate)))
                if number_of_shares == 0:
                    return 0, 0, 0
                total_cost = number_of_shares * price
                commission = total_cost * commission_rate
                total_cost_including_commission = total_cost + commission
                while total_cost_including_commission > cash_available and number_of_shares > 0:
                    number_of_shares -= 1
                    total_cost = number_of_shares * price
                    commission = total_cost * commission_rate
                    total_cost_including_commission = total_cost + commission
                return number_of_shares, total_cost, commission
            
            # Îß§ÎèÑ Ïãú ÏàúÏàòÏùµ Í≥ÑÏÇ∞ Ìï®Ïàò
            def calculate_proceeds_from_selling(number_of_shares, sell_price, commission_rate, transaction_tax_rate):
                total_proceeds = number_of_shares * sell_price
                commission = total_proceeds * commission_rate
                transaction_tax = total_proceeds * transaction_tax_rate
                net_proceeds = total_proceeds - commission - transaction_tax
                return net_proceeds, commission, transaction_tax
            
            # Ï†ÑÎûµ Íµ¨ÌòÑ
            for date, row in df.iterrows():
                high = row['Í≥†Í∞Ä']
                low = row['Ï†ÄÍ∞Ä']
                close = row['Ï¢ÖÍ∞Ä']
                
                price_sequence = [
                    ('low', low),
                    ('high', high),
                    ('close', close)
                ]
                
                for price_type, price in price_sequence:
                    # Îß§Ïàò Î°úÏßÅ
                    if waiting_for_initial_price:
                        if price <= initial_buy_price and cash >= unit_investment:
                            number_of_shares, total_cost, commission = calculate_number_of_shares_to_buy(
                                cash, unit_investment, initial_buy_price, commission_rate)
                            if number_of_shares > 0:
                                total_cost_including_commission = total_cost + commission
                                holdings += number_of_shares
                                cash -= total_cost_including_commission
                                buy_count = 1
                                buy_levels.append({'price': initial_buy_price, 'shares': number_of_shares})
                                waiting_for_initial_price = False
                    else:
                        if buy_count == 0 and cash >= unit_investment and price_type == 'close':
                            buy_price = price
                            number_of_shares, total_cost, commission = calculate_number_of_shares_to_buy(
                                cash, unit_investment, buy_price, commission_rate)
                            if number_of_shares > 0:
                                total_cost_including_commission = total_cost + commission
                                holdings += number_of_shares
                                cash -= total_cost_including_commission
                                initial_buy_price = buy_price
                                buy_count = 1
                                buy_levels.append({'price': buy_price, 'shares': number_of_shares})
                        elif buy_count > 0:
                            target_buy_price = buy_levels[-1]['price'] * (1 - buy_next_percent_decimal)
                            if (price <= target_buy_price) and (buy_count < max_buy_times) and (cash >= unit_investment):
                                buy_price = target_buy_price
                                number_of_shares, total_cost, commission = calculate_number_of_shares_to_buy(
                                    cash, unit_investment, buy_price, commission_rate)
                                if number_of_shares > 0:
                                    total_cost_including_commission = total_cost + commission
                                    holdings += number_of_shares
                                    cash -= total_cost_including_commission
                                    buy_count += 1
                                    buy_levels.append({'price': buy_price, 'shares': number_of_shares})
                            
                            target_sell_price = buy_levels[-1]['price'] * (1 + sell_percent_decimal)
                            if (price >= target_sell_price):
                                sell_price = target_sell_price
                                last_buy_level = buy_levels[-1]
                                number_of_shares_to_sell = last_buy_level['shares']
                                net_proceeds, commission, transaction_tax = calculate_proceeds_from_selling(
                                    number_of_shares_to_sell, sell_price, commission_rate, transaction_tax_rate)
                                holdings -= number_of_shares_to_sell
                                cash += net_proceeds
                                buy_count -= 1
                                buy_levels.pop()
                                
                                if buy_count == 0:
                                    waiting_for_initial_price = True
            
            total_value = cash + holdings * close
            total_return = (total_value - initial_investment) / initial_investment * 100
            
            results.append({
                'Îß§Ïàò Í∞≠ %': buy_next_percent,
                'Îß§ÎèÑ %': sell_percent,
                'Ï¥ù ÏàòÏùµÎ•† (%)': total_return
            })
            
            # ÏßÑÌñâ ÏÉÅÌô© ÏóÖÎç∞Ïù¥Ìä∏
            my_bar.progress(iteration / total_iterations)
    
    # Í≤∞Í≥º Îç∞Ïù¥ÌÑ∞ÌîÑÎ†àÏûÑ Î∞è ÌîºÎ≤ó ÌÖåÏù¥Î∏î ÏÉùÏÑ±    
    results_df = pd.DataFrame(results)
    pivot_table = results_df.pivot(index='Îß§Ïàò Í∞≠ %', columns='Îß§ÎèÑ %', values='Ï¥ù ÏàòÏùµÎ•† (%)').astype(float)
    pivot_table = pivot_table.round(2)
    pivot_table.columns = ['Îß§ÎèÑ {}%'.format(col) for col in pivot_table.columns]
    
    st.subheader('üìä Î∞±ÌÖåÏä§ÌåÖ Í≤∞Í≥º')
    st.dataframe(pivot_table.style.format("{:.2f}").background_gradient(cmap='RdYlGn', axis=None))
        
    # ÏµúÏ†ÅÏùò ÏàòÏùµÎ•† Î∞è Ìï¥Îãπ Î≥ÄÏàò Ï°∞Ìï© Ï∞æÍ∏∞
    max_return = results_df['Ï¥ù ÏàòÏùµÎ•† (%)'].max()
    optimal_row = results_df.loc[results_df['Ï¥ù ÏàòÏùµÎ•† (%)'] == max_return].iloc[0]
    optimal_buy_next_percent = optimal_row['Îß§Ïàò Í∞≠ %']
    optimal_sell_percent = optimal_row['Îß§ÎèÑ %']
    
    st.write(f"üèÜ ÏµúÏ†ÅÏùò Ï¥ù ÏàòÏùµÎ•†ÏùÄ {max_return:.2f}%Ïù¥Î©∞, Îß§Ïàò Í∞≠ %Îäî {optimal_buy_next_percent}%, Îß§ÎèÑ %Îäî {optimal_sell_percent}%ÏûÖÎãàÎã§.")
    
    # ÏµúÏ†ÅÏùò Î≥ÄÏàòÎ°ú Î∞±ÌÖåÏä§ÌåÖ Í≤∞Í≥º ÏãúÍ∞ÅÌôî
    st.subheader('üìà ÏµúÏ†ÅÏùò Î≥ÄÏàòÎ°ú Î∞±ÌÖåÏä§ÌåÖ Í≤∞Í≥º ÏãúÍ∞ÅÌôî')
    
    # ÏµúÏ†ÅÏùò Î≥ÄÏàòÎ°ú Îã§Ïãú Î∞±ÌÖåÏä§ÌåÖ Ïã§Ìñâ (Îß§Îß§ ÎÇ¥Ïó≠ Î∞è Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Í∞ÄÏπò Í∏∞Î°ù)
    buy_next_percent = optimal_buy_next_percent
    sell_percent = optimal_sell_percent
    buy_next_percent_decimal = buy_next_percent / 100
    sell_percent_decimal = sell_percent / 100
    
    holdings = 0
    cash = initial_investment
    portfolio_value = []
    dates = []
    trade_history = []
    
    commission_rate = 0.00015
    transaction_tax_rate = 0.0018
    
    initial_buy_price = None
    waiting_for_initial_price = False
    buy_count = 0
    buy_levels = []
    
    for date, row in df.iterrows():
        high = row['Í≥†Í∞Ä']
        low = row['Ï†ÄÍ∞Ä']
        close = row['Ï¢ÖÍ∞Ä']
        
        price_sequence = [
            ('low', low),
            ('high', high),
            ('close', close)
        ]
        
        for price_type, price in price_sequence:
            if waiting_for_initial_price:
                if price <= initial_buy_price and cash >= unit_investment:
                    number_of_shares, total_cost, commission = calculate_number_of_shares_to_buy(
                        cash, unit_investment, initial_buy_price, commission_rate)
                    if number_of_shares > 0:
                        total_cost_including_commission = total_cost + commission
                        holdings += number_of_shares
                        cash -= total_cost_including_commission
                        buy_count = 1
                        buy_levels.append({'price': initial_buy_price, 'shares': number_of_shares})
                        trade_history.append({
                            'Date': date, 'Type': 'Buy', 'Price': initial_buy_price, 
                            'Holdings': holdings, 'Cash': cash, 'Buy_Count': buy_count, 'Shares': number_of_shares
                        })
                        waiting_for_initial_price = False
            else:
                if buy_count == 0 and cash >= unit_investment and price_type == 'close':
                    buy_price = price
                    number_of_shares, total_cost, commission = calculate_number_of_shares_to_buy(
                        cash, unit_investment, buy_price, commission_rate)
                    if number_of_shares > 0:
                        total_cost_including_commission = total_cost + commission
                        holdings += number_of_shares
                        cash -= total_cost_including_commission
                        initial_buy_price = buy_price
                        buy_count = 1
                        buy_levels.append({'price': buy_price, 'shares': number_of_shares})
                        trade_history.append({
                            'Date': date, 'Type': 'Buy', 'Price': buy_price, 
                            'Holdings': holdings, 'Cash': cash, 'Buy_Count': buy_count, 'Shares': number_of_shares
                        })
                elif buy_count > 0:
                    target_buy_price = buy_levels[-1]['price'] * (1 - buy_next_percent_decimal)
                    if (price <= target_buy_price) and (buy_count < max_buy_times) and (cash >= unit_investment):
                        buy_price = target_buy_price
                        number_of_shares, total_cost, commission = calculate_number_of_shares_to_buy(
                            cash, unit_investment, buy_price, commission_rate)
                        if number_of_shares > 0:
                            total_cost_including_commission = total_cost + commission
                            holdings += number_of_shares
                            cash -= total_cost_including_commission
                            buy_count += 1
                            buy_levels.append({'price': buy_price, 'shares': number_of_shares})
                            trade_history.append({
                                'Date': date, 'Type': 'Buy', 'Price': buy_price, 
                                'Holdings': holdings, 'Cash': cash, 'Buy_Count': buy_count, 'Shares': number_of_shares
                            })
                    
                    target_sell_price = buy_levels[-1]['price'] * (1 + sell_percent_decimal)
                    if (price >= target_sell_price):
                        sell_price = target_sell_price
                        last_buy_level = buy_levels[-1]
                        number_of_shares_to_sell = last_buy_level['shares']
                        net_proceeds, commission, transaction_tax = calculate_proceeds_from_selling(
                            number_of_shares_to_sell, sell_price, commission_rate, transaction_tax_rate)
                        holdings -= number_of_shares_to_sell
                        cash += net_proceeds
                        trade_history.append({
                            'Date': date, 'Type': 'Sell', 'Price': sell_price, 
                            'Holdings': holdings, 'Cash': cash, 'Buy_Count': buy_count, 'Shares': number_of_shares_to_sell
                        })
                        buy_count -= 1
                        buy_levels.pop()
                        
                        if buy_count == 0:
                            waiting_for_initial_price = True
        
        total_value = cash + holdings * close
        portfolio_value.append(total_value)
        dates.append(date)
    
    # -------------------------------
    # Ï∫îÎì§Ï∞®Ìä∏Ïóê Îß§Îß§ ÏãúÏ†ê ÌëúÏãú (mplfinance)
    # -------------------------------
    df_candle = df.rename(columns={'ÏãúÍ∞Ä': 'Open', 'Í≥†Í∞Ä': 'High', 'Ï†ÄÍ∞Ä': 'Low', 'Ï¢ÖÍ∞Ä': 'Close'})
    
    buy_signals = pd.Series(np.nan, index=df_candle.index)
    sell_signals = pd.Series(np.nan, index=df_candle.index)
    
    for trade in trade_history:
        if trade['Type'] == 'Buy':
            buy_signals.loc[trade['Date']] = trade['Price']
        elif trade['Type'] == 'Sell':
            sell_signals.loc[trade['Date']] = trade['Price']
    
    apds = [
        mpf.make_addplot(buy_signals, type='scatter', markersize=100, marker='^', color='green'),
        mpf.make_addplot(sell_signals, type='scatter', markersize=100, marker='v', color='red')
    ]
    

    
    fig, ax = mpf.plot(
        df_candle,
        type='candle',
        style='yahoo',
        addplot=apds,
        returnfig=True,
        title=f'{target_ticker} () Buy and Sell Signals (Optimized Parameters)',
        ylabel='Price (KRW)'
    )
    
    for trade in trade_history:
        if trade['Type'] == 'Buy':
            ax[0].annotate(f"{int(trade['Buy_Count'])}", xy=(trade['Date'], trade['Price']),
                           xytext=(0,10), textcoords='offset points', color='green', ha='center')
        elif trade['Type'] == 'Sell':
            ax[0].annotate(f"{int(trade['Buy_Count'])}", xy=(trade['Date'], trade['Price']),
                           xytext=(0,-15), textcoords='offset points', color='red', ha='center')
    
    st.pyplot(fig)
    
    # Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ Í∞ÄÏπò Î≥ÄÌôî ÏãúÍ∞ÅÌôî
    portfolio_series = pd.Series(portfolio_value, index=dates)
    fig2, ax2 = plt.subplots(figsize=(12, 6))
    ax2.plot(portfolio_series.index, portfolio_series.values)
    ax2.set_title('Portfolio Value Change (Optimized Parameters)')
    ax2.set_xlabel('Date')
    ax2.set_ylabel('Portfolio Value (KRW)')
    ax2.grid(True)
    
    st.pyplot(fig2)
    
    # Îß§Îß§ ÎÇ¥Ïó≠ ÌëúÏãú (ÏïÑÏù¥ÏΩò Ï∂îÍ∞Ä)
    st.subheader('üìú Îß§Îß§ ÎÇ¥Ïó≠')
    trade_history_df = pd.DataFrame(trade_history)
    trade_history_df.set_index('Date', inplace=True)
    st.dataframe(trade_history_df)
    st.write("For inquiries: jsm02115@naver.com")
    
    # ========================================================
    # DB Ï†ÄÏû•: Î∞±ÌÖåÏä§Ìä∏ Ïã§Ìñâ Ïãú ÏÇ¨Ïö©Ìïú Í∞í Î∞è Í≤∞Í≥ºÎ•º ÌïòÎÇòÏùò .db ÌååÏùºÏóê Ï†ÄÏû•
    # ========================================================
    conn = sqlite3.connect("backtest_results.db")
    cursor = conn.cursor()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS backtest_runs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            run_timestamp TEXT,
            target_ticker TEXT,
            ticker_name TEXT,
            initial_investment REAL,
            unit_investment REAL,
            max_buy_times INTEGER,
            start_date TEXT,
            end_date TEXT,
            buy_next_percent_start REAL,
            buy_next_percent_end REAL,
            buy_next_percent_step REAL,
            sell_percent_start REAL,
            sell_percent_end REAL,
            sell_percent_step REAL,
            optimal_buy_next_percent REAL,
            optimal_sell_percent REAL,
            max_return REAL
        )
    """)
    conn.commit()
    
    run_timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    ticker_name = stock.get_market_ticker_name(target_ticker)
    
    cursor.execute("""
        INSERT INTO backtest_runs (
            run_timestamp, target_ticker, ticker_name, initial_investment, unit_investment, max_buy_times,
            start_date, end_date, buy_next_percent_start, buy_next_percent_end, buy_next_percent_step,
            sell_percent_start, sell_percent_end, sell_percent_step, optimal_buy_next_percent,
            optimal_sell_percent, max_return
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    """, (
        run_timestamp, target_ticker, ticker_name, initial_investment, unit_investment, max_buy_times,
        start_date_input.strftime('%Y-%m-%d'), end_date_input.strftime('%Y-%m-%d'),
        buy_next_percent_start, buy_next_percent_end, buy_next_percent_step,
        sell_percent_start, sell_percent_end, sell_percent_step,
        optimal_buy_next_percent, optimal_sell_percent, max_return 
    ))
    conn.commit()
    conn.close()
    # st.success("‚úÖ Î∞±ÌÖåÏä§Ìä∏ Í≤∞Í≥ºÍ∞Ä Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!")
